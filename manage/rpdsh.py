import readline
import datetime
import time
import shlex
import colors
import json

from flask import current_app

from visual.models import User, RemoteDataset, RemoteEvent, AuthToken
from visual.core import db


class RemoteProcessingShell:
    """Шелл для отправки событий в датасеты юзера."""
    def run(self, user_email, dataset_id=None, clear=False):
        self.user = User.query.filter(db.func.lower(User.email) == user_email.lower()).first()
        self.dataset = None

        if not self.user:
            self.error(f'Пользователь с почтой "{user_email}" не найден')
            return

        if dataset_id is not None:
            self.cmd_use(dataset_id)

        print('Юзер: ' + colors.bold(self.user.email))

        # Ищем авторизационный токен юзера для запросов к API и создаём его, если нужно
        self.token = AuthToken.query.filter(AuthToken.user_id == self.user.id,
                                            AuthToken.expires > datetime.datetime.now()).first()
        if self.token:
            print(f'API-токен найден, "{self.token.title}", expires={self.token.expires}')
        else:
            self.token = AuthToken(
                user_id=self.user.id, ip='0.0.0.0', expires=datetime.datetime.now() + datetime.timedelta(days=30),
                signature=AuthToken.generate(),
                title='generated by RPDSH'
            )
            db.session.add(self.token)
            db.session.commit()
            print(f'API-токен создан, "{self.token.title}", expires={self.token.expires}')

        if self.dataset:
            print('Датасет: ' + colors.bold(self.dataset.remote_id))
        else:
            print('Датасет не выбран, выберите командой "use <dataset_id>')
        print(colors.green('Справка вызывается командой "help".'))

        while True:
            try:
                if self.dataset:
                    dataset_sig = self.dataset.remote_id
                else:
                    dataset_sig = 'NONE'

                try:
                    cmdline = shlex.split(
                        input(colors.bold(f'RPDSH [{self.user.email}/{dataset_sig}]') + colors.faint(' >>> ')))
                except ValueError as e:
                    self.error('Синтаксическая ошибка в команде: ' + str(e))
                    continue
                if len(cmdline) == 0:
                    continue

                commands = {
                    'help': self.cmd_help,
                    'ls': self.cmd_ls,
                    'use': self.cmd_use,
                    'rm': self.cmd_rm,
                    'clear': self.cmd_clear,
                    'create': self.cmd_create,
                    'event': self.cmd_event,
                    'auto': self.cmd_auto,
                }
                if cmdline[0] in commands:
                    commands[cmdline[0]](*cmdline[1:])
                else:
                    self.error(f'Нет такой команды - "{cmdline[0]}". Зато есть команда "help".')

            except (KeyboardInterrupt, EOFError):
                print('\nПока-пока.')
                exit()

    def api_request(self, method, endpoint, body, _debug=False):
        with current_app.test_client() as client:
            kw = {
                'method': method,
                'json': body,
                'query_string': {
                    'client': 'rpdsh',
                    'client_version': '1.0.0',
                    'auth_token': str(self.token)
                }
            }
            url = '/api/v3{}'.format(endpoint)

            if _debug:
                print('\nAPI REQUEST [{}] {}'.format(url, kw))

            rv = client.open(url, **kw)

            if _debug:
                print('HTTP STATUS: ', rv.status_code)
                print('HTTP RESPONSE HEADERS:\n', rv.headers)
                print('HTTP RESPONSE BODY:')
                if rv.headers.get('Content-Type') == 'application/json':
                    resp = json.loads(rv.get_data(as_text=True))
                    print(json.dumps(resp, indent=4, ensure_ascii=False))
                else:
                    print(rv.get_data(as_text=True))
            elif rv.status_code != 200:
                self.error(
                    f'API {kw["method"]} {url} вернул ошибкy [{rv.status_code}]:\n' + str(rv.get_data(as_text=True)))
                return False

            return rv

    def error(self, msg):
        print(colors.red(msg))
        print()

    def cmd_help(self, *_):
        print('Remote Processing Interface Debug Shell.')
        print('В командах можно использовать shell-синтаксис, то есть, заключать параметры с пробелами в двойные')
        print('или одинарные кавычки (и экранировать другие кавычки внутри бэкслешем).')
        print()
        print('Команды:')
        print()
        print('ls                   Вывести список датасетов текущего юзера')
        print('use                  Показать свойства текущего датасета')
        print('use <dataset_id>     Использовать датасет <dataset_id>')
        print('rm <dataset_id>      Удалить <dataset_id>')
        print('create <dataset_id> [<title>=null] [<props>=null] [<type>="filincam"]')
        print('                     Создать датасет')
        print('event <type> [<meta>=null] [<job_id>=null]')
        print('                     Послать евент в текущий датасет')
        print('auto <start> <finish> [<delay>=1]')
        print(
            '                     Шлёт серию евентов от типа <start> до типа <finish> с интервалом <speed> секунд между ними.')
        print('                     У эвентов *.progress увеличивает значение meta.progress на 0.2 каждое событие.')
        print('                     Например, чтобы проэмулировать весь цикл обработки сцены, можно сказать')
        print('                     auto upload.started transfer.success')
        print('clear')
        print('^D, ^C               Выйти')
        print()

    def cmd_ls(self, *_):
        print('Датасеты юзера:')
        for ds in RemoteDataset.query.filter_by(user_id=self.user.id).order_by(RemoteDataset.created.desc()):
            print(f'  {ds.remote_id}: {ds.type} {ds.created} "{ds.title}"')

    def cmd_use(self, dataset_id=None, *_):
        if dataset_id is None:
            # Вызвали без аргументов
            if self.dataset is None:
                print('Не используется никакой датасет.')
            else:
                print('Используется датасет:')
                for attr in ('created', 'user_id', 'type', 'remote_id', 'title', 'props', 'last_event'):
                    print(f'  {attr}: {getattr(self.dataset, attr)}')
            return

        dataset = RemoteDataset.query.filter_by(user_id=self.user.id, remote_id=dataset_id).first()
        if not dataset:
            self.error(f'Датасет "{dataset_id}" не найден у юзера "{self.user.email}')
            return

        self.dataset = dataset
        print(f'Выбран датасет {self.dataset.remote_id} "{self.dataset.title}"')

    def cmd_create(self, dataset_id=None, title=None, props=None, type_='filincam', *_):
        if dataset_id is None:
            self.error('Укажите ID датасета')
            return

        if props is not None:
            try:
                props = json.loads(props)
            except json.decoder.JSONDecodeError as e:
                self.error('У вас ошибка в JSON-строке для RemoteDataset.props: ' + str(e))
                return
        else:
            props = {}

        check = RemoteDataset.query.filter_by(type=type_, remote_id=dataset_id).first()
        if check:
            self.error('Датасет с тамим ID уже существует в системе. Придумайте другой.')
            return

        dataset = RemoteDataset(
            user_id=self.user.id,
            remote_id=dataset_id,
            title=title,
            type=type_,
            props=props
        )
        db.session.add(dataset)
        db.session.commit()
        self.dataset = dataset

        print(f'Создан датасет "{dataset_id}"')

    def cmd_rm(self, dataset_id=None, *_):
        yes = input('Точно? Скажите "yes": ')
        if yes != 'yes':
            return

        dataset = RemoteDataset.query.filter_by(user_id=self.user.id, remote_id=dataset_id).first()
        if not dataset:
            self.error(f'Датасет "{dataset_id}" не найден у юзера "{self.user.email}')
            return
        if self.dataset.id == dataset.id:
            self.dataset = None
        db.session.delete(dataset)
        db.session.commit()

    def cmd_clear(self, *_):
        yes = input(f'Точно удалить все датасеты юзера {self.user.email}? Скажите "yes, blya": ')
        if yes != 'yes, blya':
            return

        self.dataset = None
        RemoteDataset.query.filter_by(user_id=self.user.id).delete()
        db.session.commit()

        print('Все датасеты текущего юзера удалены.')

    def cmd_event(self, type_=None, meta=None, job_id=None, *_):
        if self.dataset is None:
            self.error('Сначала выберите датасет (команда use)')
            return

        if type_ not in current_app.config['REMOTE_EVENT_TYPES'].get(self.dataset.type, []):
            self.error(f'Неизвестный тип события "{type_}" для типа датасета "{self.dataset.type}"')
            return

        if meta is not None:
            try:
                meta = json.loads(meta)
            except json.decoder.JSONDecodeError as e:
                self.error('У вас ошибка в JSON-строке для RemoteEvent.meta: ' + str(e))
                return
        else:
            meta = {}

        rv = self.api_request(
            'POST',
            f'/remote-processing/datasets/filincam/{self.dataset.remote_id}/events',
            {'type': type_, 'job_id': job_id, 'meta': meta}
        )
        if rv:
            print(f'В датасет "{self.dataset.remote_id}" отправлено событие "{type_}", ответ API:')
            print(rv.get_data(as_text=True))

    def cmd_auto(self, start=None, finish=None, delay=1, *_):
        if self.dataset is None:
            self.error('Сначала выберите датасет (команда use)')
            return

        try:
            delay = float(delay)
        except ValueError:
            self.error(f'Интервал в третьем параметре задаётся числом, а "{delay}" - не число.')
            return

        print(f'Шлём события от {start} до {finish} с интервалом {delay} сек.')
        print(f'Нажмите ^C, чтобы прервать процесс.')

        flow = [
            ('upload.started', {}),
            ('upload.progress', {'progress': .1}),
            ('upload.progress', {'progress': .3}),
            ('upload.progress', {'progress': .5}),
            ('upload.progress', {'progress': .7}),
            ('upload.progress', {'progress': .9}),
            ('upload.success', {}),
            ('processing.started', {}),
            ('processing.progress', {'progress': .1}),
            ('processing.progress', {'progress': .3}),
            ('processing.progress', {'progress': .5}),
            ('processing.progress', {'progress': .7}),
            ('processing.progress', {'progress': .9}),
            ('processing.success', {}),
            ('transfer.started', {}),
            ('transfer.progress', {'progress': .1}),
            ('transfer.progress', {'progress': .3}),
            ('transfer.progress', {'progress': .5}),
            ('transfer.progress', {'progress': .7}),
            ('transfer.progress', {'progress': .9}),
            ('transfer.success', {}),
        ]

        if start is not None:
            try:
                x = next(x for x in enumerate(flow) if x[1][0] == start)
            except StopIteration:
                self.error(f'События "{start}" нет в нормальном ходе событий')
                return
            start_pos = x[0]
        else:
            start_pos = 0

        if finish is not None:
            try:
                x = next(x for x in reversed(list(enumerate(flow))) if x[1][0] == finish)
            except StopIteration:
                self.error(f'События "{finish}" нет в нормальном ходе событий')
                return
            finish_pos = x[0]
        else:
            finish_pos = len(flow)

        try:
            for type_, meta in flow[start_pos:finish_pos + 1]:
                print(f'> {type_} {meta}\r', end='')
                rv = self.api_request(
                    'POST',
                    f'/remote-processing/datasets/filincam/{self.dataset.remote_id}/events',
                    {'type': type_, 'meta': meta}
                )
                time.sleep(delay)
        except KeyboardInterrupt:
            print('\nОстановлено.')
            return

        print()

